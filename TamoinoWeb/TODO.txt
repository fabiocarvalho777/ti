TODO
####

Usar Maven para controlar build
Ao criar nova word, validar URL com javascript, para assegurar que começa necessariamente com http:// ou https://
validar form de sigin com javasscript
	validar campos nulos e email (@ blah blah)
Criar entidade de páginas que saibam dizer tudo sobre si mesmas, como titulo, botoes da toolbar, etc
	Configurar tais páginas usando XML
	Será que o XML também dirá quem será o jsp? qual seria a vantagem disso?
Fazer DTOs dentro do pacote Persistence. As classes de model tem factories para DTOs
	Finalizar DTO factories
Substituir Webmee por Tamoino na UI
Remover qualquer referência no código ou UI que se remeta a palavra Webmee. Deixar genérico, sem qualquer referência ao nome do produto
Criar abstract factory para os DAOS (dependendo de cada DBMS usado, como em http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html)
	Colocar o DBConnHelper dentro de cada implementação de DAOFactory
Adicionar parametros de requests em Page, fazendo referências em JSPs e Servlets
Colocar logo na UI
Enumerar de alguma forma todos os atributos de Session
O DBHelper vai se desmembrar em DAOs individuais apra Entities ;-)	
Adaptar interfaces e implementações de DAOs para uso de DTOs
	1-Talvez os DAOs nunca retornem um BO (Business Object), talvez eles sempre retornem um DTO (DTO->BO)
	2-Talvez os DAOs nunca recebam um BO (Business Object) como parâmetro, talvez eles sempre recebam valores individuais ou um DTO (BO->DTO)
	3-Alguns dizem que BO->DTO é o correto, e que DTO->BO não faz o menor sentido. Se isso for verdade, então provavelmente os DAOs salvam DTOs e retornam BOs. Mas ainda assim, nesse caso como os BOs seriam enviados pelos DAOs via rede de volta? Afinal, não foi isso que justificou a criação dos DTOs quando houve a necessidade de enviar os BOs pela rede aos DAOs? Estou pendendo mais para as duas primeiras afirmações.
	4-Caso 1 e 2 sejam verdade, então os clientes dos DAOs, sejam eles quem for, devem se encarregar de fazer as conversóes DTO->BO (ao receberem um DTO) e BO->DTO (antes de enviarem um DTO). Obviamente tais clientes podem delegar essa tarefa a alguém especializado nessas conversóes.
	* Os DTOs não precisam se restringir às características dos BOs. Eles podem guardar menos informações, dependendo do contexto e de como seráo necessórios. Além disso, um único DTO pode conter informações sobre mais de um BO. É claro que em casos como esses, os BOs envolvidos sempre tem um forte relacionamento entre si.
	* Os DTOs são usados em outros contextos também, além da comunicação com DAOs, como por exemplo quando enviar informação à camada de apresentação.
Adaptar controllers para o uso de novos DAOs
Fixar posições dos elementos no toptoolbar (para que sejam as mesmas em qualquer página)
TI está explodindo quando usuário tenta adicionar uma palavra que já existe (testar ambos os casos, quando a palvra foi previamente adicionada pelo mesmo usuário ou por outro)
Adicionar o email do usuário no toptoolbar quando logado
Fazer o container subir o servidor do HSQLDB, assim facilitará os testes. Porém, parametrizar essa opção, para que possa ser desligada em modo produção.
Criar um FrontController servlet
Adicionar o nome da página corrente no banner do topo
O termo Word está se tornando confuso. Internamente, ele significa uma coluna da tabela Entry e um atributo da entidade Entry. Porém, para o usuário final, ele significa a Entry toda. Isso precisa ser resolvido.
Adicionar flag no servidor HSQLDB em memória para ter ou não demo data
Estudar e adicionar FrontController
Substituir "enabled" por "active" em todo o projeto em Entry
Mover todo o código Web para um projeto no Eclipse separado e dependente do TI core. Repensar o deployment (dois wars separados dentro de um EAR?)
Adicionar suporte a grupos
Pensar sobre a possibilidade de ter um Account ou AccountDTO na Session, ao invés do email e account id separados (Fazer isso, pois também é útil ter o account type sempre disponível!)
Renomear Group para EntryGroup e GroupType para EntryGroupType em todo o projeto
Completar test cases para testes funcionais automatizados
Encontrar uma forma de parametrizar todo o texto usado em test cases de testes funcionais automatizados
Add automated functional test using a free software tool similar to RFT (probably Selenium)
Entender melhor como Separar o projeto todos em dois (Core e Web). Por exemplo, onde fica a REST API? No Core?





Fazer uso máximo de JSP e taglibs!
Ao criar nova word, validar URL para assegurar que ela existe (provavelmente feita server-side, mas talvez dê para fazer via javascript também)
Renomer Controllers para Adapters? Criar interfaces para todos os Adapters?
Adicionar validação também do lado do servidor (em que camada?)
Estudar e substituir todos HTTP request assíncronos com forms por REST calls
Criar um servlet que trate qualquer URL direta * (uso do serviço sem usar a UI)
Substituir web.xml por anotações servlet-api 3.0
Adicionar logger (Pesquisar melhor ferramenta. Log4J talvez?)
Adicionar internacionalização com Spring
Usar JUnit para testes unitários
Gerenciar melhor o tratamento de exceções do projeto todo
Melhorar o javadoc do projeto todo
Fazer com que o keypress=13 do último campo de todo formulário submeta o formulário
Ao digitar uma palavra que não existe na Go page, ao invés de limpar o textbox, o seu texto deve ficar todo selecionado (assim o usuário poderá recomeçar uma palavra nova, ou alterar a existente)
Resolver todos warnings
Estudar onde inserir validação, e tratar a validação do projeto todo
Consertar o validateURL em script.js. não está aceitando URL de evento do Facebook
Adicionar "activationDate" em Entry. Esse campo pode ser null, mas se não for, a Entry estará obrigatoriamente desabilitada assim que criada, e automaticamente será ativada na data estabelecida.
Adicionar verificador de email ao criar nova conta (um código com link deve ser enviado ao email, só depois disso a conta é ativada). Para tal, deverá haver um atributo a mais em Account chamado "active".
Adicionar image check ao criar uma conta para evitar que robôs ataquem o TI com DoS
Pesquisar sobre como encriptar o password na mensagem POST. HTTPS é a única solução? Resolver esse problema
Criar gerenciamento de sessão na index page (e error page também), para evitar que essa página seja aberta e se comporte como se o usuário não estivesse logado, quando ele na verdade está.
Verificar tamanhos mínimos e máximos de caracteres para nomes de gruop names e keys. Assegurar no user agent e servidor que isso é verificado
GWT vs DOJO vs JQuery
Struts vs Spring MVC
Adicionar feature para deletar conta (usando cliente de webservice)
Criar tabela de mensagens com ids para todas as mensagens da UI Web (internacionalizada)
Segurança, pesquisar e aplicar proteção para SQL Injection e Cross-site scripting
Pesquisar HTML5. Usar?
Pesquisar WebProxy. Usar?
Pesquisar Worklight (http://www.worklight.com/) quando for desenvolver a parte Mobile
Pesquisar UX (user experience) e aplicá-la!
WebTest
	Completar a interface Constants preenchendo Field, Label e Message
	Criar um seed de texto para test cases de testes funcionais automatizados, assim eles poderão ser executados repetidamente sem ter que reiniciar o servidor ou fazer um redeploy
	Verificar mais uma vez se é possível mover o conteúdo do projeto de WebTest para dentro do projeto Web.
Adicionar webservice REST e webservice SOAP sobre JMS